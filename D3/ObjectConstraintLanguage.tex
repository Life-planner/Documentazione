\section{Object Constraint Language}
\label{secD3:ObjectConstraintLanguage}

In questo capitolo è descritta in modo formale la logica prevista nell'ambito di alcune operazioni di alcune classi. Tale logica viene descritta in Object Constraint Language (OCL) perché tali concetti non sono esprimibili in nessun altro modo formale nel contesto di UML.


\begin{listaPersonale}{OCL}
    \elemento[Utenti]{ocl:Utenti}
    \begin{center}
        \includesvg[width=0.85\textwidth, height=0.75\textheight]{img/svg/DCL/Tipologie_Utenti.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/DCL/Tipologie_Utenti.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/DCL/Tipologie_Utenti.svg}{SVG} Diagramma delle classi "Tipologie di Utenti"}
    \end{center}
    Nella classe “UtenteNonAutenticato” (\ref{dcl:TipologieUtenti}) è presente il metodo “Autenticazione()”, la cui esecuzione comporta l'inizializzazione degli attributi "UserId", "Email" e "Username", a dei valori non vuoti; infatti grazie a questo metodo l' utente non autenticato diventa utente autenticato. \\
    Questa condizione è espressa in OCL attraverso una postcondizione con questo codice:
    \begin{lstlisting}
CONTEXT UtenteNonAutenticato::AutenticazioneECaricamento() : 
POST : UserId <> "" AND Email <> "" AND Username <> ""
    \end{lstlisting}
    Dopo il metodo “Autenticazione()”, ci sono tre condizioni che si verificano per ogni “UtenteAutenticato”: "UserId", "Email" e "Username" non devono essere vuoti. \\ Questa condizione è espressa in OCL, attraverso un invariante con questo codice:
    \begin{lstlisting}
CONTEXT UtenteAutenticato : 
INV : UserId <> "" AND Email <> "" AND Username <> ""
    \end{lstlisting}
    Nella classe “UtenteAutenticato” (presenta in \ref{dcl:TipologieUtenti}) è presente il metodo “GoHomepage()”, la cui esecuzione avviene se e solo se l' "UserId", l' "Username" e l' "Email" non sono vuoti, ovviamente questo avviene sempre per ogni utente autenticato, in quanto gli utenti autenticati non potrebbero essere definiti tali con gli attributi, sopra citati, vuoti. \\
    Dopo l'esecuzione del “GoHomepage()”, ci sono tre condizioni che si verificano: UserId, Email e Username sono vuoti, in quanto l'utente autenticato è uscito dal sito e non più attivo su esso. \\
    Queste precondizioni e postcondizioni sono rappresentati con il seguente codice OCL:
    \begin{lstlisting}
CONTEXT UtenteAutenticato::GoHomepage() :
POST : UserId  = "" AND Email  = "" AND Username  = ""
    \end{lstlisting}





    \elemento[Auth0]{ocl:Auth0}
    \begin{center}
        \includesvg[width=0.55\textwidth,height=0.45\textheight]{img/svg/DCL/Interfaccia_auth0.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/DCL/Interfaccia_auth0.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/DCL/Interfaccia_auth0.svg}{SVG} Diagramma delle classi "InterfacciaAuth0"}
    \end{center}
    Nella classe "InterfacciaAuth0" (presenta in \ref{dcl:Auth0}) ci sono delle condizioni che devono essere sempre, ovvero che "Auth0Secret", "Auth0BaseUrl", "Auth0IssuerBaseUrl", "Auth0ClientId" e Auth0ClientSecret" non devono essere stringhe vuote, infatti ognuna di esse è un URL fondamentale per il reindirizzamento dell'utente alla pagina di autenticazione di Auth0.
    \begin{lstlisting}
CONTEXT InterfacciaAuth0:
INV : Auth0Secret <> "" AND Auth0BaseUrl <> "" AND Auth0IssuerBaseUrl <> "" AND Auth0ClientId  <> "" AND Auth0ClientSecret<> ""
    \end{lstlisting}

    Nella classe “InterfacciaAuth0”  è presente il metodo “RedirectToAutenticationPage()”, metodo che reindirizza l'utente alla pagina di autenticazione, la cui esecuzione restituisce i valori "AUserId", "AUsername" e "AEmail" che vengono attribuiti ai rispettivi attributi presenti in “UtenteAutenticato”. \\
    Questa condizione è espressa in OCL attraverso una postcondizione con questo codice:
    \begin{lstlisting}
CONTEXT Interfaccia_Auth0::RedirectToAutenticationPage() :
POST : Utente_Autenticato.UserId = AUserId AND Utente_Autenticato.Email = AEmail AND Utente_Autenticato.Username = AUsername
    \end{lstlisting}
    \newpage



    \elemento[Gestione Impostazioni Utente]{ocl:ImpostazioniUtente}
    \begin{center}
        \includesvg[width=0.60\textwidth, height=0.50\textheight]{img/svg/OCL/GestioneImpostazioniUtente.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/GestioneImpostazioniUtente.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/GestioneImpostazioniUtente.svg}{SVG} Diagramma delle classi "Gestione Impostazioni Utente"}
    \end{center}
    Nella classe “GestioneImpostazioniUtente” (di cui abbiamo già parlato in parte in \ref{dcl:ImpostazioniAccount}) ci sono delle condizioni che devono essere sempre vere. Infatti l'attributo “SistemaMappe”, attributo che indica il sistema di mappe scelto dall'utente autenticato per la definizione delle coordinate del luogo di un evento, deve essere uguale alla stringa “OSM”, che si riferisce al sistema esterno di mappe OpenStreeMap, o alla stringa “GM”, Google Maps. Infatti il sistema di mappe deve essere per forza scelto fra un di questi due. \\
    Inoltre anche l'attributo "OreSonno" deve essere, per ovvi motivi di coerenza con la realtà, maggiore di zero. \\
    Infine, l'attributo Premium, che indica se l'utente autenticato sia standard o premium, è uguale al valore dell'attributo "Abbonato", presente nella classe "GestioneAbbonamento" (di cui abbiamo già parlato in parte in \ref{dcl:Abbonamento}): classe che gestisce la sottoscrizione e cancellazione di un abbonamento da parte dell'utente autenticato.
    Queste condizioni sono espresse in OCL attraverso la seguente espressione:
    \begin{lstlisting}
CONTEXT GestioneImpostazioniUtente:
INV : (SistemaMappe = "OSM" OR SistemaMappe = "GM") AND OreSonno >= 0 AND Premium = Abbonamento.Abbonato
    \end{lstlisting}
    Inoltre, in questa classe, è presente anche il metodo “CambiaUsername(NUsername)” per cui devono esserci delle condizioni che devono essere verificate prima dell'esecuzione. Infatti il nuovo username, "NUsername", con cui si vuole modificare l'username presente, non deve essere una stringa vuota. \\
    Questa condizione è espressa in OCL attraverso la seguente precondizione:
    \begin{lstlisting}
CONTEXT GestioneImpostazioniUtente::CambiaUsername(NUsername):
PRE : NUsername <> "" AND Utente_Autenticato.Username <> NUsername
POST : Utente_Autenticato.Username = NUsername
    \end{lstlisting}
    Nella classe “GestioneImpostazioniUtente” (\ref{dcl:ImpostazioniAccount}) per il metodo “CambiaNumeroOreSonno (Nore)” c'è una precondizione che deve essere verificata, prima dell'esecuzione del metodo, ovvero che "NOre", le nuove ore che stiamo inserendo con numero di ore di sonno, deve essere maggiore e uguale a 0 e diverso dalle ore di sonno già inserite in “GestioneImpostazioniUtente”, quindi in OCL abbiamo:
    \begin{lstlisting} 
CONTEXT GestioneImpostazioniUtente::CambiaNumeroOreSonno(Nore):
PRE : NOre >= 0 AND NOre <> self.OreSonno
POST : self.OreSonno = NOre
    \end{lstlisting}
    In seguito, in questa classe è presente il metodo “GetSistemaMappe()” per cui si verifica una postcondizione, ovvero che la stringa che viene restituita da questa funzione, che indica il metodo di sistema di mappe scelto dall'utente autenticato, deve essere uguale all'attributo “SistemaMappe” presente in “ImpostazioniUtente”. \\ Questa postcondizione è espressa dal seguente codice OCL:\\
    \begin{lstlisting}
CONTEXT GestioneImpostazioniUtente::GetSistemaMappe():
POST : return = SistemaMappe 
    \end{lstlisting}
    Infine, nella classe “GestioneImpostazioniUtente” per il metodo \\"CambiaSistemaMappe(NSistemaMappe)" c'è una precondizione che deve essere verificata, prima dell'esecuzione del metodo, ovvero che il nuovo sistema di mappe scelto dall'utente autenticato, "NSistemaMappe", e il sistema di mappe presente ora in “GestioneImpostazioniUtente” deve essere uguale a “OSM” (stringa che si riferisce a OpenStreetMap) o “GM” (Google Maps).
    Dopo, l'esecuzione del metodo si verifica una postcondizione; infatti dopo la modifica del sistema di mappe, il sistema di mappe presente nell'attributo “SistemaMappe” deve essere uguale al sistema di mappe nuovo, "NSistemaMappe", che è stato usato come parametro nel metodo “CambiaSistemaMappe(NSistemaMappe).\\
    Queste condizioni nel contesto, “CambiaSistemaMappe(NSistemaMappe), sono espresse con il seguente codice OCL:

    \begin{lstlisting}
CONTEXT GestioneImpostazioniUtente::CambiaSistemaMappe(NSistemaMappe):
PRE : (NSistemaMappe = "OSM" AND self.SistemaMappe = "GM") OR (NSistemaMappe = "GM" AND self.SistemaMappe = "OSM")
POST : self.SistemaMappe = NSistemaMappe
    \end{lstlisting}




    \elemento[Gestione Modifica Password]{ocl:GestioneModificaPassword}
    \begin{center}
        \includesvg[width=0.55\textwidth, height=0.45\textheight]{img/svg/OCL/GestioneModificaPassword.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/GestioneModificaPassword.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/GestioneModificaPassword.svg}{SVG} Diagramma delle classi "Gestione Modifica Password"}
    \end{center}
    Nella classe “GestioneModificaPassword” (di cui abbiamo già parlato in parte in \ref{dcl:ModificaPasswordAuth0API}) è presente il metodo\\ “ControlloValiditaPassword(NPassword)" il quale, dopo aver eseguito, ritorna un booleano. Il valore di questo dipende dal fatto se la nuova password inserita, "NPassword", segua o meno gli standard già presentati in \prettyref{D1-rnf:SicurezzaPassword}.
    \begin{lstlisting}
CONTEXT GestioneModificaPassword::ControlloValiditaPassword(NPassword) :
POST : return = NPassword.size() >= 8 AND NPassword.exists(carattere | carattere = [a, ..., z]) AND NPassword.exists(carattere | carattere = [A, ..., Z]) AND NPassword.exists(carattere | carattere = [0, ..., 9]) AND NPassword.exists(carattere | carattere = [!, #, \$, \%, \&, \*])
    \end{lstlisting}
    \newpage

    \elemento[Auth0 management API]{ocl:Auth0ManagementAPI}
    \begin{center}
        \includesvg[width=0.65\textwidth, height=0.55\textheight]{img/svg/OCL/Auth0ManagementAPI.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/Auth0ManagementAPI.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/Auth0ManagementAPI.svg}{SVG} Diagramma delle classi "Auth0 management API"}
    \end{center}
    Nella classe “Auth0 management API” (di cui abbiamo già parlato in parte in \ref{dcl:ModificaPasswordAuth0API}) ci sono delle condizioni che devono essere sempre verificate, ovvero che l'attributo “EndPoint”, stringa che indica l'URL di Auth0 a cui posso accedere per modificare la password, e “AuthorizationToken”, token dato da Auth0 agli utenti autenticati per accedere alle API di Auth0, non devono essere vuoti. Infatti queste attributi sono neccessari per permettere all'utente di modificare la propria password.\\
    Queste invarianti è espressa da OCL mediante la seguente espressione OCL:
    \begin{lstlisting}
CONTEXT Auth0ManagementAPI :
INV : EndPoint <> "" AND AuthorizationToken <> ""
    \end{lstlisting}
    Inoltre, in questa classe è presente il metodo “CambiaPassword(UserId, NuovaPassword)”, il quale, per essere eseguito, deve essere verificata una precondizione, ovvero che "UserId", Id dell'utente autenticato che sta cambiando la password, non deve essere vuoto. Inoltre, il metodo “ControlloValiditàPassword(NPassword)” della classe “GestioneModificaPassword”, mi deve aver verificato che "NPassword" sia valida, restituendomi come risultato "true". Questa precondizione è specificata dal seguente codice OCL:
    \begin{lstlisting}
CONTEXT Auth0ManagementAPI::CambiaPassword(UserId, NuovaPassword) :
PRE : UserId <> "" AND GestioneModificaPassword.ControlloValidiaPassword(NPassword)
    \end{lstlisting}




    \elemento[Gestione Abbonamento]{ocl:Abbonamento}
    \begin{center}
        \includesvg[width=0.45\textwidth, height=0.35\textheight]{img/svg/OCL/GestioneAbbonamento.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/GestioneAbbonamento.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/GestioneAbbonamento.svg}{SVG} Diagramma delle classi "Gestione Abbonamento"}
    \end{center}
    Nella classe “GestioneAbbonamento” (di cui abbiamo già parlato in parte in \ref{dcl:Abbonamento}), è presente il metodo “SottoscrizioneAbbonamento()”. Affinché possa avvenire la sottoscrizione all'abbonamento deve essere verificata una precondizione, ovvero che l'attributo “Abbonato”, presente in questa classe, sia uguale a “false”. Dopo l'esecuzione di tale metodo si verifica una postcondizione: l'attributo “Abbonato” è uguale a “true”, questo vuol dire che l'utente autenticato si è sottoscritto, ovviamente, all'abbonamento.\\
    Questa pre e post-condizione sono espressi in OCL con il seguente codice:
    \begin{lstlisting}
CONTEXT GestioneAbbonamento::SottoscrizioneAbbonamento() :
PRE : Abbonato = false
POST : Abbonato = true
    \end{lstlisting}
    Inoltre, nella classe “GestioneAbbonamento”, è presente anche il metodo “CancellazioneAbbonamento()”. Affinché possa avvenire la cancellazione all'abbonamento deve essere verificata una precondizione, ovvero che l'attributo “Abbonato”, presente in questa classe, sia uguale a "true". Dopo l'esecuzione di tale metodo si verifica una postcondizione: l'attributo “Abbonato” è uguale a “false”; infatti l'abbonamento è stato annullato.\\
    Questa pre e post-condizione sono espressi in OCL con il seguente codice:
    \begin{lstlisting}
CONTEXT GestioneAbbonamento::CancellazioneAbbonamento() :
PRE : Abbonato = true
POST : Abbonato = false
    \end{lstlisting}




    \elemento[Gestione Visualizzazione calendari ed eventi]{ocl:VisualizzazioneCalendariEventi}
    \begin{center}
        \includesvg[width=0.65\textwidth, height=0.55\textheight]{img/svg/OCL/VisualizzazioneCalendariEventi.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/VisualizzazioneCalendariEventi.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/VisualizzazioneCalendariEventi.svg}{SVG} Diagramma delle classi "Gestione Visualizzazione calendari ed eventi"}
    \end{center}
    Nella classe "GestioneVisualizzazioneCalendariEventi" (già presentata in \ref{dcl:VisualizzazioneCalendari}) è presente una condizione che deve essere sempre valida, ovvero che l'attributo "IntervalloVistaEventi" abbia un valore temporale valido, secondo i valori presentati in questa invariante:
    \begin{lstlisting}
CONTEXT GestioneVisualizzazioneCalendariEventi :
INV : IntervalloVistaEventi = "Giorno" OR IntervalloVistaEventi = "Settimana" OR IntervalloVistaEventi = "Mese" AND Calendari = GestioneFiltriCalendari.GetListaCalendariFiltrati()
    \end{lstlisting}
    Nella classe “GestioneVisualizzazioneCalendariEventi”, con l'esecuzione del metodo “CambiaIntervalloVistaUtenti(NIntervallo)”, si ha che l'attributo di questa classe “IntervalloVistaUtenti” è uguale al parametro “NIntervallo” utilizzato nel metodo sopra citato. \\
    Questa postcondizione è espressa con il seguente codice OCL:
    \begin{lstlisting}
CONTEXT GestioneVisualizzazioneCalendariEventi:: CambiaIntervalloVistaUtenti(NIntervallo) :
PRE : NIntervallo = "Giorno" OR NIntervallo = "Settimana" OR NIntervallo = "Mese"
POST : IntervalloVistaEventi = NIntervallo
    \end{lstlisting}
    \newpage



    \elemento[Calendario]{ocl:Calendario}
    \begin{center}
        \includesvg[width=0.65\textwidth, height=0.55\textheight]{img/svg/OCL/Calendario.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/Calendario.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/Calendario.svg}{SVG} Diagramma delle classi "Calendario"}
    \end{center}
    Nella classe “Calendario” (già presentata in \ref{dcl:CreazioneModificaCalendario}) deve essere verificata sempre una condizione, ossia che l'IdCalendario, Id che identifica univocamente un calendario nel database MongoDB, e il suo nome non devono essere stringhe vuote. Inoltre, anche il proprietario di tale calendario deve essere diverso da “Null”.\\
    Queste invarianti presentate, sono espresse dal seguente codice OCL:
    \begin{lstlisting}
CONTEXT Calendario :
INV : IdCalendario <> "" AND Nome <> "" AND Proprietario <> Null
    \end{lstlisting}
    Inoltre, in questa classe è presente un metodo “Crea(Principale)” (il parametro e attributo “Principale” serve ad indicare se stiamo andando a modificare il calendario principale o uno degli altri calendari di un utente) che, con la sua esecuzione, fa in modo che l'attributo “Proprietario” della classe “Calendario” sia uguale ad “UserId”, Id dell'utente che ha creato o modificato tale calendario. Infine, nell'attributo "Partecipanti" deve essere presente l' "UserID" di chi ha modifica o creato tale calendario, in quanto, ovviamente, è un partecipante di tale calendario. \\
    Questa postcondizione è presenta dall'OCL:
    \begin{lstlisting}
CONTEXT Calendario::Crea(Principale)
POST : Proprietario = Utente_Autenticato.UserId AND Partecipanti -> exists(u | u.UserId = Utente_Autenticato.UserId )
    \end{lstlisting}
    Infine, con il metodo “Salva(NNome,NFuso,NColore)" andiamo a modificare i seguenti attributi della classe “Calendario”: “Nome”, “Fuso”, “Colore”. Infatti questi attributi ottengono il valore dei nuovi attributi assegnati con il metodo salva, ovvero "NNome", "NFuso" e "NColore". \\
    Questa postcondizione è espressa in OCL nel seguente modo:
    \begin{lstlisting}
CONTEXT Calendario::Salva(NNome, NFuso, NColore)
POST : Nome = NNome AND Fuso = NFuso AND NColore = Colore
    \end{lstlisting}
    \newpage



    \elemento[Evento]{ocl:Evento}
    \begin{center}
        \includesvg[width=0.45\textwidth, height=0.35\textheight]{img/svg/OCL/Evento.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/Evento.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/Evento.svg}{SVG} Diagramma delle classi "Evento"}
    \end{center}
    Nella classe “Evento” (già presentata in \ref{dcl:CreazioneModificaEvento}), ci sono delle condizioni che devono essere sempre verificate, ovvero che l' “IdEvento”, Id che identifica univocamente un evento un calendario nel database MongoDB, e il “Titolo” non devono essere vuoti; inoltre, anche il proprietario, ovvero l'utente autenticato che sta creando l'evento, deve essere diverso da “Null”, dunque in OCL si ha:
    \begin{lstlisting}
CONTEXT Evento :
INV : IdEvento <> "" AND Proprietario <> Null AND Titolo <> ""
    \end{lstlisting}
    In questa classe, è presente il metodo “Crea(NTitolo)". Affinchè quest'ultimo possa eseguire, “NTitolo”, ovvero il titolo che si vuole attribuire all'evento che si sta creando, deve essere diverso dalla stringa vuota; infatti non si può creare un "Evento" senza titolo, non avrebbe senso. Dopo l'esecuzione di questo metodo, l'attributo “Proprietario” deve essere uguale ad UserId, Id dell'utente autenticato che sta creando l'evento, e “Titolo” a “NTitolo”, il titolo scelto per l'evento. Infine, nell'attributo "Partecipanti" deve essere presente l' "UserID" di chi ha modifica o creato tale evento, in quanto, ovviamente, è un partecipante di tale evento. \\
    Tali condizioni sono presentati dal seguente codice OCL:
    \begin{lstlisting}
CONTEXT Evento::Crea(NTitolo)
PRE : Ntitolo <> ""
POST : Proprietario = Utente_Autenticato.UserId AND Titolo = NTitolo AND Partecipanti -> exists(u | u.UserId = Utente_Autenticato.UserId )
    \end{lstlisting}
    Infine, in questa classe è presente il metodo “Salva(NTitolo , NDescrizione , NPriorita , NDifficolta , NLuogo)”. Per eseguire questo metodo, deve esser verificato che il titolo inserito per l'Evento da salvare sia diverso dalla stringa vuota. \\
    Dopo l'esecuzione del metodo, gli attributi dell'oggetto “Evento” saranno uguali ai parametri inseri in tale metodo “Salva”. \\
    Queste condizioni sono rappresentante dal seguente codice OCL:

    \begin{lstlisting}
CONTEXT Evento::Salva(NTitolo, NDescrizione, NPriorita, NDifficolta, NLuogo)
PRE : Ntitolo <> ""
POST : Titolo = NTitolo AND Descrizione = NDescrizione AND Priorita = NPriorita AND Difficolta = NDifficolta AND Luogo = NLuogo 
    \end{lstlisting}




    \elemento[Gestione Chiamate MongoDB]{ocl:GestioneMongoDB}
    \begin{center}
        \includesvg[width=0.50\textwidth, height=0.40\textheight]{img/svg/OCL/ChiamateMongoDB.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/ChiamateMongoDB.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/ChiamateMongoDB.svg}{SVG} Diagramma delle classi "Gestione Chiamate MongoDB"}
    \end{center}
    Nella classe “Gestione Chiamate MongoDB” (già presentata in \ref{dcl:MongoDB}) ci sono delle condizioni che devono essere sempre verificate; infatti l'attributo “Link”, attributo in cui è salvato l'URL del database MongoDB con cui interagisce questa classe, e la “Password”, necessaria per poter accedere e interagire sempre con il database MongoDB, non devono essere vuoti. Infatti, se lo fossero, la classe “Gestione Chiamate MongoDB” non potrebbe gestire le chiamate tra MongoDB e l'applicativo.\\
    Queste condizioni sono presentate con del codice OCL nel seguente modo:

    \begin{lstlisting}
CONTEXT GestioneChiamateMongoDB :
INV : Link <> "" AND Password <> "" 
    \end{lstlisting}




    \elemento[Tipo Data]{ocl:TipoData}
    \begin{center}
        \includesvg[width=0.40\textwidth, height=0.30\textheight]{img/svg/OCL/Tipo_Data.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/Tipo_Data.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/Tipo_Data.svg}{SVG} Diagramma delle classi "Tipo Data"}
    \end{center}
    Nella classe “Tipo\_Data” (già mostrata in \ref{dcl:TipoData}) sono presenti delle condizioni che devono essere verificate, ovvero che gli attributi “Ora”, “Minuti”, “Giorno” e “Mese” devono avere dei valori che siano coerenti agli intervalli temporali imposti dalla convenzione sul tempo nella realtà.\\
    Tali condizione sono presentate dal seguente codice OCL:

    \begin{lstlisting}
CONTEXT Tipo_Data:
INV : Ora >= 0 AND Ora <= 23 AND
Minuti >= 0 AND Minuti <= 60 AND
Giorno >= 1 AND Giorno <= 31
Mese >= 1 AND Mese <= 12
    \end{lstlisting}




    \elemento[Tipo Luogo]{ocl:TipoLuogo}
    \begin{center}
        \includesvg[width=0.40\textwidth, height=0.30\textheight]{img/svg/OCL/Tipo_Luogo.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/Tipo_Luogo.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/Tipo_Luogo.svg}{SVG} Diagramma delle classi "Tipo Luogo"}
    \end{center}
    Anche nella classe “Tipo\_Luogo” (già mostrata in \ref{dcl:TipoLuogo}) sono presenti dei requisiti che devono essere sempre rispettati. Gli attributi “Latitudine” e “Longitudine” non devono essere delle stringhe vuote, in quanto indicano le coordinate di un luogo. \\
    Queste condizioni sono descritte in OCL nel seguente modo:

    \begin{lstlisting}
CONTEXT Tipo_Luogo:
INV : Latitudine <> "" AND Longitudine <> "" 
    \end{lstlisting}


    \elemento[Tipo Fuso Orario]{ocl:TipoFusoOrario}
    \begin{center}
        \includesvg[width=0.40\textwidth, height=0.30\textheight]{img/svg/OCL/Tipo_Fuso_Orario.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/svg/OCL/Tipo_Fuso_Orario.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/Tipo_Fuso_Orario.svg}{SVG} Diagramma delle classi "Tipo Fuso Orario"}
    \end{center}
    In questa classe (già mostrata in \ref{dcl:FusoOrario}), ci sono delle condizioni che devono essere sempre rispettate, ovvero che l'attributo “GMToffset” abbia un valore che sia coerente con l'intervallo di valori che può assumere l'offset di un fuso orario rispetto a Greenwich secondo le convenzioni poste nella realtà.\\
    Dunque, è stato fatto questo codice OCL:

    \begin{lstlisting}
CONTEXT Tipo_Fuso_Orario:
INV : GMToffset >= -12 AND GMToffset <= 12 
    \end{lstlisting}




    \elemento[Tipo Calendario Filtrato]{ocl:TipoCalendarioFiltrato}
    \begin{center}
        \includesvg[width=0.40\textwidth, height=0.30\textheight]{img/svg/OCL/Tipo_Calendario_Filtrato.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/Tipo_Calendario_Filtrato.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/Tipo_Calendario_Filtrato.svg}{SVG} Diagramma delle classi "Tipo Calendario Filtrato"}
    \end{center}
    Anche la classe “Tipo\_Calendario\_Filtrato” (già mostrata in \ref{dcl:CalendarioFiltrato}) presenta delle condizioni che devono essere sempre verificate, cioè che l'attributo “CalendarioFiltrato”, che contiene un calendario dell'utente autenticato, deve essere diverso da “Null”. Infatti questo tipo di dato è utilizzato per andare a filtrare i calendari posseduti da un utente autenticato, dunque per forza deve essere diverso da “Null”. \\
    Queste condizioni sono presentate dal seguente codice OCL:
    \begin{lstlisting}
CONTEXT Tipo_Calendario_Filtrato
INV: CalendarioFiltato <> Null
    \end{lstlisting}




    \elemento[Tipo Link Richiesta]{ocl:TipoLinkRichiesta}
    \begin{center}
        \includesvg[width=0.55\textwidth, height=0.45\textheight]{img/svg/OCL/Tipo_Link_Richiesta.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/Tipo_Link_Richiesta.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/Tipo_Link_Richiesta.svg}{SVG} Diagramma delle classi "Tipo Link Richiesta"}
    \end{center}
    La classe “Tipo\_Link\_Richiesta” (di cui abbiamo discusso in \ref{dcl:TipoLinkRichiesta}) ha dei requisiti riguardo a dei suoi attributi che devono essere sempre rispettati. Infatti, questo tipo di dato, utilizzato per fare le richieste di condivisione di eventi o calendari, non può avere entrambe le stringhe “IdCalendario”, id utlizzato per identificare univocamente un calendario, “IdEvento”, id che identifica univocamente un Evento, vuote. Inoltre anche “Account” deve avere un valore diverso da “Null”. \\ Questo è necessario, perché un oggetto di tipo “Tipo\_Link\_Richiesta” viene istanziato se e solo se si vuole condividere effettivamente un calendario o evento che si creando o modificando appartenente ad un utente autenticato avente, ovviamente, un account.\\
    Queste condizioni sono rappresentate dall'OCL:

    \begin{lstlisting}
CONTEXT Tipo_Link_Richiesta:
INV : (IdCalendario <> "" AND IdEvento = "") OR (IdCalendario = "" AND IdEvento <> "") AND Account <> Null
    \end{lstlisting}
    Inoltre, in questa classe, nel contesto del metodo “creaRichiesta (IdCalendario, IdEvento, Account) ci sono delle precondizioni che devono essere rispettate prima di una sua esecuzione. Infatti, prima dell'esecuzione del metodo, devono essere rispettate le condizioni già citate nelle invarianti, ma che stavolta sono imposte sui parametri di questa funzione. Si noti che i parametri della funzione sono diversi dagli attributi, prima dell'esecuzione di questa funzione.\\
    Infine, dopo l'esecuzione di questo metodo, abbiamo delle postcondizioni. Infatti, dopo che si esegue questa funzione, che può essere intesa come un vero e proprio costruttore di un oggetto di questo tipo di dato, gli attributi di un oggetto di questa classe assumono i valori inseriti come parametri nel metodo “creaRichiesta”. \\
    Queste postcondizioni e precondizioni sono espresse nel seguente codice OCL:

    \begin{lstlisting}
CONTEXT Tipo_Link_Richiesta::creaRichiesta(IdCalendario, IdEvento, Account)
PRE : (IdCalendario <> "" AND IdEvento = "") OR (IdCalendario = "" AND IdEvento <> "") AND Account <> Null
POST : self.IdCalendario = IdCalendario AND self.IdEvento = IdEvento AND  self.Account = Account  
    \end{lstlisting}




    \elemento[Gestione Luoghi]{ocl:GestioneLuoghi}
    \begin{center}
        \includesvg[width=0.55\textwidth, height=0.45\textheight]{img/svg/OCL/GestioneLuoghi.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/GestioneLuoghi.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/GestioneLuoghi.svg}{SVG} Diagramma delle classi "Gestione Luoghi"}
    \end{center}
    Questa classe (di cui abbiamo già discusso in \ref{dcl:GestioneLuoghi}) ha delle precondizioni che devono essere rispettate per l'esecuzione del metodo “ConvertIndirizzoToCordinate(indirizzo)”, ovvero che l'indirizzo, che deve essere convertito in delle coordinate geografiche, deve essere diverso, ovviamente, da una stringa vuota.\\
    Questa precondizione è espressa nel codice OCL:

    \begin{lstlisting}
Context GestioneLuoghi::ConvertIndirizzoToCordinate (indirizzo):
PRE : indirizzo <> ""
    \end{lstlisting}




    \elemento[Interfaccia Google Maps API]{ocl:GoogleMapsAPI}
    \begin{center}
        \includesvg[width=0.40\textwidth, height=0.30\textheight]{img/svg/OCL/GoogleCalendarAPI.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/GoogleCalendarAPI.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/GoogleCalendarAPI.svg}{SVG} Diagramma delle classi "Interfaccia Google Maps API"}
    \end{center}
    La classe “InterfacciaGoogleMapsAPI” (di cui abbiamo discusso in \ref{dcl:GestioneLuoghi}) ha delle invarianti che devono essere sempre verificate, ovvero che non devono essere delle stringhe vuote l' “EndPoint”, URL con cui si accede alle API di Google Maps, e ApiToken, che è il “token” dell'account Google dell'utente autenticato che ha deciso di usare Google Maps come sistema esterno, "token" che ci permette di accedere alle API di Google Maps.\\
    Queste invarianti sono descritte con questo codice OCL:
    \begin{lstlisting}
CONTEXT InterfacciaGoogleMapsAPI :
INV : Endpoint <> "" AND ApiToken <> ""
    \end{lstlisting}




    \elemento[Interfaccia OpenStreatMap API]{ocl:OpenStreatMapAPI}
    \begin{center}
        \includesvg[width=0.40\textwidth, height=0.30\textheight]{img/svg/OCL/OpenStreetMapAPI.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/OpenStreetMapAPI.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/OpenStreetMapAPI.svg}{SVG} Diagramma delle classi "Interfaccia OpenSteetMap API"}
    \end{center}
    La classe “InterfacciaOpenStreetMapAPI” (di cui abbiamo discusso in \ref{dcl:GestioneLuoghi}) ha un' invariante che deve essere sempre verificata, ovvero che l' “EndPoint”, URL con cui si accede alle API di OpenStreetMap, non deve essere una stringa vuota. A differenza di Google Maps, OpenStreetMap non richiede un account nel suo applicativo, e quindi neanche un token, per accedere alle sue API e servizi; per questo motivo non è presente nessun attributo di nome "token".\\
    Questa invariante è descritta in OCL:
    \begin{lstlisting}
CONTEXT InterfacciaOpenStreetMapAPI :
INV : Endpoint <> ""
    \end{lstlisting}




    \elemento[Gestione Impostazioni Ripetizione Base]{ocl:ImpostazioniRipetizioneBase}
    \begin{center}
        \includesvg[width=0.40\textwidth, height=0.30\textheight]{img/svg/OCL/RipetizioneBase.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/RipetizioneBase.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/RipetizioneBase.svg}{SVG} Diagramma delle classi "Gestione Impostazioni Ripetizioni Base"}
    \end{center}
    La classe “GestioneImpostazioniRipetizioneBase” (già presentata in
    \ref{dcl:CreazioneModificaEvento}) ha delle invarianti che devono essere sempre rispettate, ovvero che “NumeroRipetizioni” dell'evento, di cui stiamo impostando le ripetizioni, deve essere maggiore o uguale a 1 e che la durata di tale evento sia maggiore o uguale a 0. Infatti, non avrebbe senso l'esistenza di un evento ripetuto, senza che questo fosse presente almeno in un giorno con un durata non nulla.\\
    Queste invarianti sono presentate dal seguente codice OCL:

    \begin{lstlisting}
CONTEXT GestioneImpostazioniRipetizioneBase:
INV : NumeroRipetizioni >= 1 AND Durata >= 0
    \end{lstlisting}




    \elemento[Gestione Giornata]{ocl:Giornata}
    \begin{center}
        \includesvg[width=0.40\textwidth, height=0.30\textheight]{img/svg/OCL/Giornata.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/Giornata.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/Giornata.svg}{SVG} Diagramma delle classi "Gestione Giornata"}
    \end{center}
    La classe “GestioneGiornata” (già presentata in \ref{dcl:CreazioneModificaEvento}), utilizzata per indicare il giorno in cui avviene un evento ripetuto, ha un'invariante; questa riguarda l'attributo “GiornoDellaSettimana”, che ovviamente, deve assumere il valore di un giorno della settimana esistente.\\
    Questa invariante è descritta dal seguente OCL:

    \begin{lstlisting}
CONTEXT GestioneGiornata:
INV : GiornoDellaSettimana = "L" OR
GiornoDellaSettimana = "Ma" OR
GiornoDellaSettimana = "Me" OR
GiornoDellaSettimana = "G" OR
GiornoDellaSettimana = "V" OR
GiornoDellaSettimana = "S" OR
GiornoDellaSettimana = "D"
    \end{lstlisting}




    \elemento[Evento Ripetuto]{ocl:EventoRipetuto}
    \begin{center}
        \includesvg[width=0.45\textwidth, height=0.35\textheight]{img/svg/OCL/EventoRipetuto.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/EventoRipetuto.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/EventoRipetuto.svg}{SVG} Diagramma delle classi "Evento Ripetuto"}
    \end{center}
    La classe “EventoRipetuto” (già presentata in \ref{dcl:CreazioneModificaEvento}) ha un'invariante che riguarda l'attributo “DurateIntervallo”, ovvero periodo di tempo per cui deve essere valido tale evento ripetuto. Infatti “DurataIntervallo” deve avere un valore di periodo temporale che sia valido, ovvero o durata di un giorno, o mese, o settimana o anno. \\
    Questo è il codice OCL che descrive questa invariante:
    \begin{lstlisting}
CONTEXT EventoRipetuto:
INV : DurataIntervallo = "Giorno" OR DurataIntervallo = "Settimana" OR DurataIntervallo = "Mese" OR 
DurataIntervallo = "Anno"
    \end{lstlisting}




    \elemento[Evento Singolo]{ocl:EventoSingolo}
    \begin{center}
        \includesvg[width=0.40\textwidth, height=0.30\textheight]{img/svg/OCL/EventoSingolo.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/EventoSingolo.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/EventoSingolo.svg}{SVG} Diagramma delle classi "Evento Singolo"}
    \end{center}
    La classe “EventoSingolo” (già mostrata in \ref{dcl:CreazioneModificaEvento}), che indica un evento che è valido solo per un giorno di cui indichiamo la data e la sua durata, ha delle condizioni che devono essere sempre rispettate. L'attributo “Durata” di un oggetto, istanza di questa classe, deve avere un valore maggiore o uguale a 0 e la “Data” deve essere diversa da “Null”, sennò tale oggetto non avrebbe nessun motivo di esistere. \\
    Per questo motivo è stato scritto questo codice OCL:

    \begin{lstlisting}
CONTEXT EventoSingolo:
INV : Durata >= 0 AND Data <> Null
    \end{lstlisting}
    \newpage



    \elemento[Gestione Sistema Di Pagamento]{ocl:SistemaPagamento}
    \begin{center}
        \includesvg[width=0.55\textwidth, height=0.45\textheight]{img/svg/OCL/SistemaDiPagamento.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/SistemaDiPagamento.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/SistemaDiPagamento.svg}{SVG} Diagramma delle classi "Gestione Sistema di Pagamento"}
    \end{center}
    Questa classe (già mostrata in \ref{dcl:SistemaPagamento}) presenta delle invarianti che devono essere sempre verificate. “TipoPagamento” deve assumere un valore che sia uguale a “PayPal” o “Stripe”, che sono i sistemi di pagamento messi a disposizione dall'applicativo per il pagamento dell'abbonamento. \\
    Questa condizione è rappresentata dal seguente codice OCL:
    \begin{lstlisting}
CONTEXT GestioneSistemaDiPagamento :
INV : TipoPagamento = "PayPal" OR TipoPagamento = "Stripe"
    \end{lstlisting}        Inoltre, in questa classe è presente una postcondizione nel contesto del metodo "CambiaSistemaDiPagamento(NSistema)"; infatti dopo l'esecuzione di tale metodo, l'attributo "TipoPagamento", che indica il sistema di pagamento scelto per pagare l'abbonamento alla versione premium di PlanIt, è uguale al parametro "NSistema" del metodo sopra citato. \\
    Questa postcondizione è espressa in OCL nel seguente modo:
    \begin{lstlisting}
CONTEXT GestioneSistemaDiPagamento::CambiaSistemaDiPagamento(NSistema) :
POST : TipoPagamento = NSistema
    \end{lstlisting}




    \elemento[Gestione Stripe]{ocl:StripeAPI}
    \begin{center}
        \includesvg[width=0.85\textwidth, height=0.75\textheight]{img/svg/OCL/StripeAPI.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/StripeAPI.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/StripeAPI.svg}{SVG} Diagramma delle classi "Gestione Stripe API"}
    \end{center}
    La classe “GestioneStripeAPI” (già mostrata in \ref{dcl:SistemaPagamento}) ha delle condizioni che devono essere sempre verificate; infatti l'attributo “ProductId”, Id che indica il prodotto abbonamento che si sta acquistando e che sarà presente nella lista di abbonamenti del proprio account di Stripe, una volta che la sottoscrizione all'account premium sarà effettuata, e l' “EndPoint”, URL delle API di Stripe con cui l'applicativo va ad interagire, non devono essere delle stringhe vuote. Se lo fossero sarebbe impossibile portare a termine una procedura di pagamento dell'abbonamento alla versione premium di PlanIt. \\
    Dunque, in codice OCL abbiamo:
    \begin{lstlisting}
CONTEXT GestioneStripeAPI :
INV : ProductId <> "" AND EndPoint <> ""
    \end{lstlisting}
    Infine, in questa classe, nel contesto del metodo "PagaSubscription()" sono presenti delle postcondizioni. Infatti "UserPaymentToken", token che indica l'user dell'account Stripe con cui si ha pagato l'abbonamento, e "PaymentId", Id che identifica univocamente il prodotto, in questo caso l'abbonamento, che si è acquistato, non devono essere delle stringhe vuote: se lo fossero l'acquisto dell'abbonamento non potrebbe essersi concluso con successo e non sarebbe neanche possibile il rinnovo automatico mensile dell'abbonamento, in quanto l'applicativo PlanIt non avrebbe delle credenziali di pagamento. Si sottolinea che questi attributi sono restituiti dal metodo "PagaSubscription()" della classe "GestioneStripeAPI", in modo tale che la classe "GestioneSistemaDiPagamentoStripe" possa provvedere al pagamento mensile automatico dell'abbonamento nel caso si fosse effettuata la sottoscrizione a questo.
    Queste postcondizioni sono espresse nel seguente codice OCL:
    \begin{lstlisting}
CONTEXT GestioneStripeAPI::PagaSubscription() :
POST : GestioneSistemaDiPagamentoPayPal.UserPaymentToken <> "" AND GestioneSistemaDiPagamentoPayPal.PaymentId <> ""
    \end{lstlisting}




    \elemento[Gestione PayPal]{ocl:PayPalAPI}
    \begin{center}
        \includesvg[width=0.85\textwidth, height=0.75\textheight]{img/svg/OCL/PayPalAPI.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/PayPalAPI.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/PayPalAPI.svg}{SVG} Diagramma delle classi "Interfaccia PayPal API"}
    \end{center}
    Nella classe, "PayPal API" (di cui ne abbiamo parlato in parte in \ref{dcl:SistemaPagamento}), come avviene nella classe "Stripe API" (\ref{ocl:StripeAPI}), gli attributi "EndPoint" e "ProductId" non possono essere delle stringhe vuote, dunque esprimiamo queste invarianti nel seguente codice OCL:
    \begin{lstlisting}
CONTEXT PayPalAPI :
INV : ProductId <> "" AND EndPoint <> ""
    \end{lstlisting}
    Inoltre, in questa classe, nel contesto del metodo “PagaSubscrition()” è presente una postcondizione. Infatti, dopo l'esecuzione di questo metodo, gli attributi “PayPalEmail”, “PayPalUserName” e “SubscriptionId”, che corrispondono alle credenziali PayPal dell'utente autenticato, che decide di pagare l'abbonamento con questo metodo, non sono delle stringhe vuote: se lo fossero l'acquisto dell'abbonamento non potrebbe essersi concluso con successo e non sarebbe neanche possibile il rinnovo automatico mensile dell'abbonamento, in quanto l'applicativo PlanIt non avrebbe delle credenziali di pagamento. Si sottolinea che questi attributi sono restituiti dal metodo "PagaSubscription()" della classe "InterfacciaPayPalAPI", in modo tale che la classe "GestioneSistemaDiPagamentoPayPal" possa provvedere al pagamento mensile automatico dell'abbonamento nel caso si fosse effettuata la sottoscrizione a questo.\\
    Questa postcondizione è espressa in OCL nel seguente modo:
    \begin{lstlisting}
CONTEXT PayPalAPI::PagaSubscription() :
POST : GestioneSistemaDiPagamentoPayPal.PayPalEmail <> "" AND GestioneSistemaDiPagamentoPayPal.PayPalUserName <> "" AND GestioneSistemaDiPagamentoPayPal.SubscriptionId <> ""
    \end{lstlisting}
    \newpage




    \elemento[Gestione Google Calendar]{ocl:GoogleCalendar}
    \begin{center}
        \includesvg[width=0.50\textwidth, height=0.40\textheight]{img/svg/OCL/GestioneGoogleCalendar.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/GestioneGoogleCalendar.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/GestioneGoogleCalendar.svg}{SVG} Diagramma delle classi "Gestione Google Calendar"}
    \end{center}
    Nella classe “GestioneGoogleCalendar” (di cui ne abbiamo parlato in parte in \ref{dcl:GoogleCalendar}) c'è il metodo “CambiaTipologiaInterazione()”. La sua esecuzione modifica il valore dell'attributo booleano “sincronizzazione” che diventa l'inverso del valore precedente all'esecuzione del metodo. Infatti questa funzione viene eseguita quando si vuole modificare il metodo di integrazione di Google Calendar con PlanIt (si ricorda che un metodo riguarda la sincronizzazione dell'account Google Calendar con quello di PlanIt, e l'altro l'import/export di file evento e/o calendario)\\
    Tale postcondizione è rappresentata dal codice OCL:
    \begin{lstlisting}
CONTEXT GestioneGoogleCalendar::CambiaTipologiaInterazione() :
POST : sincronizzazione = NOT sincronizzazione@pre 
    \end{lstlisting}




    \elemento[Gestione Import/Export]{ocl:GestioneImportExport}
    \begin{center}
        \includesvg[width=0.40\textwidth, height=0.30\textheight]{img/svg/OCL/Import_Export.svg}
        \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/Import_Export.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/Import_Export.svg}{SVG} Diagramma delle classi "Gestione Import/Export"}
    \end{center}
    Nella classe “Gestione Import/Export” (di cui ne abbiamo parlato in parte in \ref{dcl:GoogleCalendar}) ci sono delle condizioni che devono essere sempre verificate, infatti l'attributo “Sincronizzazione”, booleano che indica se stiamo usando  o meno la sincronizzazione come metodo di interazione con Google Calendar, deve essere uguale a “false”. Infatti l'interazione con Google Calendar o è fatta mediante import/export di file o mediante la sincronizzazione automatica, non si possono fare entrambe contemporaneamente.\\
    Questa invariante è presenta in OCL nel seguente modo:

    \begin{lstlisting}
CONTEXT GestioneImportExport :
INV : Sincronizzazione = false
    \end{lstlisting}
    \newpage


    \elemento[Gestione Sincronizzazione]
        {ocl:GestioneSincronizzazione}
        \begin{center}
            \includesvg[width=0.40\textwidth, height=0.30\textheight]{img/svg/OCL/Sincronizzazione.svg}
            \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/Sincronizzazione.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/Sincronizzazione.svg}{SVG} Diagramma delle classi "Gestione Sincronizzazione"}
        \end{center}
        Nella classe "Gestione Sincronizzazione" (già mostrata in \ref{dcl:GoogleCalendar}) sono presente delle condizioni che devono essere sempre rispettate. Infatti, contrariamente dalla classe "Gestione Import/Export", l'attributo "Sincronizzazione" deve essere uguale a "true"; questo indica che stiamo utilizzando la sincronizzazione come metodo di integrazione di Google Calendar con PlanIt.
        Inoltre, anche "authorizationToken", token necessario per poter accedere ad un account Google e, quindi, necessario per poter interagire con l'account Google Calendar di un utente, non deve essere una stringa vuota.\\
        Queste inviarianti presentate sono descritte da questo codice OCL:
        \begin{lstlisting}
CONTEXT GestioneSincronizzazione :
INV : Sincronizzazione = true AND authorizationToken <> ""
    \end{lstlisting}



        \elemento[Interfaccia Google Calendar API]{ocl:GoogleCalendarAPI}
        \begin{center}
            \includesvg[width=0.40\textwidth, height=0.30\textheight]{img/svg/OCL/GoogleCalendarAPI.svg}
            \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/GoogleCalendarAPI.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/GoogleCalendarAPI.svg}{SVG} Diagramma delle classi "Interfaccia Google Calendar API"}
        \end{center}
        In questa classe (già mostrata in \ref{dcl:GoogleCalendar}), è presente un'invariante che deve essere sempre valida; infatti l'attributo “EndPoint”, URL delle API di Google Calendar, non deve essere una stringa vuota, cosa necessaria per poter interagire mediante sincronizzazione con l'applicativo Google Calendar.\\
        Questa condizione è espressa nel seguente codice OCL:

        \begin{lstlisting}
CONTEXT InterfacciaGoogleCalendarAPI :
INV : Endpoint <> ""
    \end{lstlisting}
    \newpage



        \elemento[Interfaccia Iubenda]{ocl:Iubenda}
        \begin{center}
            \includesvg[width=0.45\textwidth, height=0.35\textheight]{img/svg/OCL/Iubenda.svg}
            \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/Iubenda.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/Iubenda.svg}{SVG} Diagramma delle classi "Interfaccia Iubenda"}
        \end{center}
        La classe “InterfacciaIubenda” (già presentata in \ref{dcl:Homepage}) ha delle condizioni che devono essere sempre rispettate. Infatti l'attributo “CookieBannerCode”, codice che mi serve per accedere al banner di cookie di Iubenda, e le “PoliticheDiPrivacy”, stringa che contiene le politiche di privacy ottenute da Iubenda, non devono essere delle stringhe vuote.\\
        Queste invarianti sono descritte dal seguente codice OCL:

        \begin{lstlisting}
CONTEXT InterfacciaIubenda :
INV CookieBannerCode <> "" AND PoliticheDiPrivacy <> ""
    \end{lstlisting}
        Inoltre, in questa classe nel contesto del metodo “AccettaCookie(NomeCookie)”, sono presenti delle postcondizioni. Infatti nel caso venisse accettato un cookie, questo viene aggiunto alla lista di cookie contenuto in “CookieAccettati”; per questo motivo il size di questo array aumenta di uno, rispetto al suo size prima dell'esecuzione del metodo. E, ovviamente, dopo aver accettato il cookie, questo sarà presente nell'array “CookieAccettati”. \\
        Queste postcondizioni sono descritte in OCL nel seguente modo:
        \begin{lstlisting}
CONTEXT InterfacciaIubenda::AccettaCookie(NomeCookie) :
POST : CookieAccettati.size() = CookieAccettati.size()@pre +1 AND CookieAcettati -> exists(c | c.Nome = NomeCookie)
    \end{lstlisting}
        Nel contesto del metodo RifiutaCookie(NomeCookie), sono presenti delle postcondizioni. Infatti, in quanto tale “NomeCookie” viene rifiutato dall'utente, questo non viene aggiunto dall'array di cookie “CookieAccettati”, dunque la dimensione di questa lista rimane la stessa e tale cookie non è presente in questa lista.\\
        Queste postcondizioni sono descritte in OCL:
        \begin{lstlisting}
CONTEXT InterfacciaIubenda::RifiutaCookie(NomeCookie) :
POST : CookieAccettati.size() = CookieAccettati.size()@pre AND NOT (CookieAcettati -> exists(c | c.Nome = NomeCookie))
    \end{lstlisting}
        In questa classe, nel contesto del metodo “AccettaTuttiCookies()”, l'array di “CookieAccettati” viene inizializzata ottenendo tutti i cookie presenti in “ListaCookie”, di conseguenza ha anche la sua stessa dimensione. \\
        Tutto queste sono delle postcondizioni del metodo “AccettaTuttiCookies()” che vengono descritte con il seguente codice OCL:
        \begin{lstlisting}
CONTEXT InterfacciaIubenda::AccettaTuttiCookies() :
POST : CookieAccettati.size() = ListaCookie.size() AND ListaCookies -> forAll (lc | CookieAccettati -> exists(c | c.Nome = lc.Nome))
    \end{lstlisting}
        Infine, sempre nella classe “InterfacciaIubenda” ma nel contesto del metodo “RifiutaTuttiCookies”, come condizione dopo l'esecuzione di tale metodo, possiamo dire di avere un stato opposto descritto dopo l'esecuzione del metodo “AccettaTuttiCookies()”. Infatti con questo metodo si vanno a rifiutare tutti i cookie presenti in “ListaCookies”, dunque l'array “CookieAccettati” avrà una dimensione pari a zero.\\
        Questa postcondizione è descritta dal seguente codice OCL:
        \begin{lstlisting}
CONTEXT InterfacciaIubenda::RifiutaTuttiCookies() :
POST : CookieAccettati.size() = 0
    \end{lstlisting}




        \elemento[Tipo Cookie]{ocl:TipoCookie}
        \begin{center}
            \includesvg[width=0.80\textwidth, height=0.70\textheight]{img/svg/OCL/Tipo_Cookie.svg}
            \blfootnote{Immagine \href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/png/OCL/Tipo_Cookie.png}{PNG}/\href{https://github.com/Life-planner/Documentazione/blob/main/D3/img/svg/OCL/Tipo_Cookie.svg}{SVG} Diagramma delle classi "Tipo Cookie"}
        \end{center}
        Nella classe “Tipo\_Cookie” (già presentata in \ref{dcl:Homepage}), che serve per contenere un cookie che è stato accettato dall'utente, deve essere sempre valida una condizione, ovvero che l'attributo “Nome”, stringa che contiene il nome, per l'appunto, del cookie accettato, non deve essere una stringa vuota.\\
        Questa invariante è descritta dal seguente codice OCL:
        \begin{lstlisting}
CONTEXT Tipo_Cookies :
INV : Nome <> "" 
    \end{lstlisting}
        In questa classe, nel contesto del metodo “CreaCookie(Nome, Scadenza, Chiave, Valore)” sono presenti del pre- e postcondizioni. Infatti, prima dell'esecuzione del metodo, il “Nome” del cookie, di cui stiamo andando a creare un oggetto di tipo “Tipo\_Cookie”, deve essere contenuto nell'array dei “CookieAccettati” presente nella classe "InterfacciaIubenda".\\
        Dopo l'esecuzione di questo metodo “CreaCookie”, tale oggetto di tipo “Tipo\_Cookie” viene restituito alla classe “GestioneHomepage”, dunque sarà presente nell' array “Cookie” presente in “GestioneHomepage”.\\
        Questa pre- e post-condizione sono presentate nel seguente codice OCL:
        \begin{lstlisting}
CONTEXT Tipo_Cookie::CreaCookie(Nome, Scadenza, Chiave, Valore):
PRE InterfacciaIubenda.CookieAccettati -> exists(c | c.nome=Nome)
POST  GestioneHomepage.Cookie -> exists(c | c.nome=Nome AND c.Scadenza =  Scadenza AND c.Chiave = Chiave AND c.Valore = Valore) 
    \end{lstlisting}
        Infine, nel classe “Tipo\_Cookie”, nel contesto del metodo “CancellaCookie(Nome)” è presente una postcondizione. Infatti, avendo un cookie contenuto in un oggetto di tipo “Tipo\_Cookie”, questo cookie può essere rifiutato ogni volta che sia vuole mediante questo metodo. Dopo l'esecuzione di questo metodo, il cookie rifiutato verrà eliminato dalla lista cookie presente nell'attributo “Cookie” della classe “GestioneHomepage”.\\
        Questa postcondizione è descritta in OCL nel seguente modo:

        \begin{lstlisting}
CONTEXT Tipo_Cookie::CancellaCookie(Nome)
POST : NOT ( GestioneHomepage.Cookie -> exists (c | c.Nome = Nome))
    \end{lstlisting}


\end{listaPersonale}
