\section{Object Constraint Language}
\label{secD3:ObjectConstraintLanguage}

In questo capitolo è descritta in modo formale la logica prevista nell'ambito di alcune operazioni di alcune classi. Tale logica viene descritta in Object Constraint Language (OCL) perché tali concetti non sono esprimibili in nessun altro modo formale nel contesto di UML.


\begin{listaPersonale}{OCL}
    \elemento[Utenti]{ocl:Utenti}
    Nella classe “Utente\_Non\_Autenticato” (DLC1.1) è presente il metodo “Autenticazione()”, la cui esecuzione comporta l'inizializzazione degli attributi UserId, Email e Username, a dei valori non vuoti; infatti grazie a questo metodo l' utente non autenticato diventa utente autenticato. \\
    Questa condizione è espressa in OCL attraverso una postcondizione con questo codice:
    \begin{lstlisting}
CONTEXT Utente_Non_Autenticato::AutenticazioneECaricamento() : 
POST : UserId <> "" AND Email <> "" AND Username <> ""
    \end{lstlisting}
    Dopo il metodo “Autenticazione()”, ci sono tre condizioni che si verificano per ogni “Utente\_Autenticato”: UserId, Email e Username non devono essere vuoti. \\ Questa condizione è espressa in OCL, attraverso un invariante con questo codice:
    \begin{lstlisting}
CONTEXT Utente_Autenticato : 
INV : UserId <> "" AND Email <> "" AND Username <> ""

CONTEXT Utente_Autenticato::Logout() : 
POST : UserId  = "" AND Email  = "" AND Username  = ""
    \end{lstlisting}
    Nella classe “Utente\_Autenticato” (DCL1.1) è presente il metodo “Logout()”, la cui esecuzione avviene se e solo se l'UserId, l'Username e l'Email non sono vuoti, ovviamente questo avviene sempre per ogni utente autenticato, in quanto gli utenti autenticati non potrebbero essere definiti tali con gli attributi, sopra citati, vuoti. \\
    Dopo l'esecuzione del Logout(), ci sono tre condizioni che si verificano: UserId, Email e Username sono vuoti, in quanto l'utente autenticato è uscito dal sito e non più attivo su esso. \\
    Queste precondizioni e postcondizioni sono rappresentati con il seguente codice OCL:
    \todo{Non so quanto senso abbia mettere postcondizione per il logout}
    \todo{da chiedere}



    \elemento[Auth0]{ocl:Auth0}
    Nella classe “Interfaccia\_Auth0” (DLC1.2) è presente il metodo “RedirectToAutenticationPage()”, la cui esecuzione restituisce i valori "AUserId", "AUsername" e "AEmail" che vengono attribuiti ai rispettivi attributi presenti in “Utente\_Autenticato”. \\
    Questa condizione è espressa in OCL attraverso una postcondizione con questo codice:
    \begin{lstlisting}
CONTEXT Interfaccia_Auth0:
INV : Auth0Secret <> "" AND Auth0BaseUrl <> "" AND Auth0IssuerBaseUrl <> "" AND Auth0ClientId  <> "" AND Auth0ClientSecret<> ""

CONTEXT Interfaccia_Auth0::RedirectToAutenticationPage() :
POST : Utente_Autenticato.UserId = AUserId AND Utente_Autenticato.Email = AEmail AND Utente_Autenticato.Username = AUsername
    \end{lstlisting}




    \elemento[Impostazioni Utente]{ocl:ImpostazioniUtente}
    Nella classe “ImpostazioniUtente” (DCL1.3) ci sono delle condizioni che devono essere sempre vere. Infatti l'attributo “SistemaMappe” deve essere uguale alla stringa “OSM”, che si riferisce al sistema esterno di mappe OpenStreeMap, o alla stringa “GM”, Google Maps. Infatti il sistema di mappe deve essere per forza scelto fra un di questi due. \\
    Queste condizioni sono espresse in OCL attraverso la seguente espressione:
    \begin{lstlisting}
CONTEXT ImpostazioniUtente:
INV : (SistemaMappe = "OSM" OR SistemaMappe = "GM") AND OreSonno >= 0 AND Premium = Abbonamento.Abbonato
    \end{lstlisting}
    Inoltre, in questa classe, è presente anche il metodo “CambiaUsername(NUsername)” per cui devono esserci delle condizioni che devono essere verificate prima dell'esecuzione. Infatti il nuovo username, NUsername, con cui si vuole modificare l'username presente, non deve essere una stringa vuota. \\
    Questa condizione è espressa in OCL attraverso la seguente precondizione:
    \begin{lstlisting}
CONTEXT ImpostazioniUtente::CambiaUsername(NUsername):
PRE : NUsername <> "" AND Utente_Autenticato.Username <> NUsername
POST : Utente_Autenticato.Username = NUsername
    \end{lstlisting}
    Nella classe “ImpostazioneUtente” (DCL1.3) per il metodo “CambiaNumeroOreSonno (Nore)” c'è una precondizione che deve essere verificata, prima dell'esecuzione del metodo, ovvero che NOre, le nuove ore che stiamo inserendo con numero di ore di sonno, deve essere maggiore e uguale a 0 e diverso dalle ore di sonno già inserite in “ImpostazioniUtente”, quindi in OCL abbiamo:
    \begin{lstlisting} 
CONTEXT ImpostazioniUtente::CambiaNumeroOreSonno(Nore):
PRE : NOre >= 0 AND NOre <> self.OreSonno
POST : self.OreSonno = NOre
    \end{lstlisting}
    In seguito, in questa classe è presente il metodo “GetSistemaMappe()” per cui si verifica una postcondizione, ovvero che la stringa che viene restituita da questa funzione, che indica il metodo di sistema di mappe scelto dall'utente autenticato, deve essere uguale all'attributo “SistemaMappe” presente in “ImpostazioniUtente”. \\ Questa postcondizione è espressa dal seguente codice OCL:
    \begin{lstlisting}
CONTEXT ImpostazioniUtente::GetSistemaMappe():
POST : return = SistemaMappe 
    \end{lstlisting}
    Infine, nella classe “ImpostazioniUtente” (DCL1.3) per il metodo \\ "CambiaSistemaMappe(NSistemaMappe)" c'è una precondizione che deve essere verificata, prima dell'esecuzione del metodo, ovvero che il nuovo sistema di mappe scelto dall'Utente, NSistemaMappe, e il sistema di mappe presente ora in “ImpostazioniUtente” deve essere uguale a “OSM” (stringa che si riferisce a OpenStreetMap) o “GM” (Google Maps).
    Dopo, l'esecuzione del metodo si verifica una postcondizione; infatti dopo la modifica del sistema di mappe, il sistema di mappe presente nell'attributo in “SistemaMappe” è uguale al sistema di mappe nuovo, NSistemaMappe, che è stato usato come parametro nel metodo “CambiaSistemaMappe(NSistemaMappe).\\
    Queste condizioni nel contesto, “CambiaSistemaMappe(NSistemaMappe), sono espresse con il seguente codice OCL:

    \begin{lstlisting}
CONTEXT ImpostazioniUtente::CambiaSistemaMappe(NSistemaMappe):
PRE : (NSistemaMappe = "OSM" AND self.SistemaMappe = "GM") OR (NSistemaMappe = "GM" AND self.SistemaMappe = "OSM")
POST : self.SistemaMappe = NSistemaMappe
    \end{lstlisting}
    \todo{da chiedere}




    \elemento[Gestione Modifica Password]{ocl:GestioneModificaPassword}
    Nella classe “GestioneModificaPassword” (DCL1.3.1) c'è una condizione che deve essere sempre verificata, ovvero che l'attributo “NuovaPassword” non deve essere vuoto. \\
    Per questo motivo, è stato fatto il seguente codice OCL per esprimere la seguente condizione:
    \todo{non c'e piu l'invariante}
    Inoltre, in questa classe è presente il metodo “ControlloValiditaPassword(NPassword) il quale,dopo aver eseguito, ritorna un booleano. Il valore di questo dipende dal fatto se la nuova password inserita, NuovaPassword, segua o meno gli standard già presentati in D2-RNF2 (anche D1-RNF2.1).
    \begin{lstlisting}
        CONTEXT GestioneModificaPassword::ControlloValiditaPassword(NPassword) :
        POST : return = NPassword.size() >= 8 AND NPassword.exists(carattere | carattere = [a, ..., z]) AND NPassword.exists(carattere | carattere = [A, ..., Z]) AND NPassword.exists(carattere | carattere = [0, ..., 9]) AND NPassword.exists(carattere | carattere = [!, #, $, %, &, *])
    \end{lstlisting}

    Dopo l'esecuzione del metodo “ControlloSetPassword(NPassword)”, nella classe “GestioneModificaPassword” si verifica una condizione, più specificamente una postcondizione, visto che avviene dopo l'esecuzione del metodo sopra citato. Infatti l'attributo “nuovaPassword” ha il valore di Npassword, parametro, meglio dire password, utilizzato per modificare la password di un utente autenticato.\\
    Questa condizione è espressa con il seguente codice OCL:
    \begin{lstlisting}
CONTEXT GestioneModificaPassword::ControlloSetPassword(NPassword) :
PRE : self.ControlloValiditaPassword(NPassword)
POST : Auth0ManagementAPI.CambiaPassword (Utente_Autenticato.UserId, NPassword)
    \end{lstlisting}




    \elemento[Auth0 management API]{ocl:Auth0ManagementAPI}
    Nella classe “Auth0 management API” (DCL1.3.1) c'è una condizione che deve essere sempre verificata, ovvero che l'attributo “EndPoint”, stringa che indica l'URL di Auth0 a cui posso accedere per modificare la password, e “AuthorizationToken”, token dato da Auth0 agli utenti autenticati per accedere alle API di Auth0, non devono essere vuoti. \\
    Questa invariante è espressa da OCL mediante la seguente espressione OCL:
    \begin{lstlisting}
CONTEXT Auth0ManagementAPI :
INV : EndPoint <> "" AND AuthorizationToken <> ""
    \end{lstlisting}
    Inoltre, in questa classe è presente il metodo “CambiaPassword(UserId, NuovaPassword)”, il quale, per eseguire, deve essere verificata una precondizione, ovvero che UserId, Id dell'utente autenticato che sta cambiando la password, non deve essere vuota. Inoltre, il metodo “ControlloValiditàPassword(Nuovapassword)” della classe “GestioneModificaPassword”, mi deve aver restituito un valore “true”.\\ Questa precondizione è specificata dal seguente codice OCL:
    \begin{lstlisting}
CONTEXT Auth0ManagementAPI::CambiaPassword(UserId, NuovaPassword) :
PRE : UserId <> "" AND GestioneModificaPassword.ControlloValidiaPassword(NuovaPassword)
    \end{lstlisting}




    \elemento[Abbonamento]{ocl:Abbonamento}
    Nella classe “Abbonamento”, è presente il metodo “SottoscrizioneAbbonamento()”. Affinché possa avvenire la sottoscrizione all'abbonamento deve essere verificata una precondizione, ovvero che l'attributo “Abbonato”, presente in questa classe, sia uguale a “false”. Dopo l'esecuzione di tale metodo si verifica una postcondizione: l'attributo “Abbonato” è uguale a “true”.\\
    Questa pre e post-condizione sono espressi in OCL con il seguente codice:
    \begin{lstlisting}
CONTEXT Abbonamento::SottoscrizioneAbbonamento() :
PRE : Abbonato = false
POST : Abbonato = true
    \end{lstlisting}
    Inoltre, nella classe “Abbonamento”, è presente anche il metodo “CancellazioneAbbonamento()”. Affinché possa avvenire la camcellazione all'abbonamento deve essere verificata una precondizione, ovvero che l'attributo “Abbonato”, presente in questa classe, sia uguale a "true". Dopo l'esecuzione di tale metodo si verifica una postcondizione: l'attributo “Abbonato” è uguale a “false”; infatti l'abbonamento viene annullato.\\
    Questa pre e post-condizione sono espressi in OCL con il seguente codice:
    \begin{lstlisting}
CONTEXT Abbonamento::CancellazioneAbbonamento() :
PRE : Abbonato = true
POST : Abbonato = false
    \end{lstlisting}




    \elemento[Visualizzazione calendari ed eventi]{ocl:VisualizzazioneCalendariEventi}
    \todo{da sistemare}
    \begin{lstlisting}
CONTEXT VisualizzazioneCalendariEventi :
INV : IntervalloVistaEventi = "Giorno" OR IntervalloVistaEventi = "Settimana" OR IntervalloVistaEventi = "Mese" AND Calendari = GestioneFiltriCalendari.GetListaCalendariFiltrati()
    \end{lstlisting}
    Nella classe “Visualizzazione Calendario”, con l'esecuzione del metodo “CambiaIntervalloVistaUtenti(NIntervallo)” si ha che l'attributo di questa classe “IntervalloVistaUtenti” è uguale al parametro “NIntervallo” utilizzato nel metodo sopra citato. \\
    Questa postcondizione è espressa con il seguente codice OCL:
    \begin{lstlisting}
CONTEXT VisualizzazioneCalendariEventi::CambiaIntervalloVistaUtenti(NIntervallo) :
PRE : NIntervallo = "Giorno" OR NIntervallo = "Settimana" OR NIntervallo = "Mese"
POST : IntervalloVistaEventi = NIntervallo
    \end{lstlisting}




    \elemento[Calendario]{ocl:Calendario}
    Nella classe “Calendario” deve essere verificata sempre una condizione, ossia che l'IdCalendario, Id che identifica univocamente un calendario nel database MongoDB, e il suo nome non devono essere stringhe vuote. Inoltre, anche il proprietario di tale calendario deve essere diverso da “Null”.\\
    Queste invarianti presentati, sono espressi dal seguente codice OCL:
    \begin{lstlisting}
CONTEXT Calendario :
INV : IdCalendario <> "" AND Nome <> "" AND Proprietario <> Null
    \end{lstlisting}
    Inoltre, in questa classe è presente un metodo “Crea(Principale)” (il parametro e attributo “Principale” serve ad indicare se stiamo andando a modificare il calendario principale o uno degli altri calendari di un utente) che, con la sua esecuzione, fa in modo che l'attributo “Proprietario” della classe “Calendario” sia uguale ad “UserId”, Id dell'utente che ha creato tale calendario.\\
    Questa postcondizione è presenta dall'OCL:
    \begin{lstlisting}
CONTEXT Calendario::Crea(Principale)
POST : Proprietario = Utente_Autenticato.UserId AND Partecipanti -> exists(u | u.UserId = Utente_Autenticato.UserId )
    \end{lstlisting}
    Infine, con il metodo “Salva(NNome,NFuso,NColore) andiamo a modificare i seguenti attributi della classe “Calendario”: “Nome”, “Fuso”, “Colore”. Infatti questi attributi ottengono il valore dei nuovi attributi assegnati con il metodo salva, ovvero NNome, NFuso e NColore. \\
    Questa postcondizione è espressa in OCL nel seguente modo:
    \begin{lstlisting}
CONTEXT Calendario::Salva(NNome, NFuso, NColore)
POST : Nome = NNome AND Fuso = NFuso AND NColore = Colore
    \end{lstlisting}




    \elemento[Evento]{ocl:Evento}
    Nella classe “Evento”, ci sono delle condizioni che devono essere sempre verificate, ovvero che l' “IdEvento”, Id che identifica univocamente un evento un calendario nel database MongoDB, e il “Titolo” non devono essere vuoti; inoltre, anche il proprietario, ovvero l'utente autenticato che sta creando l'evento, deve essere diverso da “Null”, dunque in OCL si ha:
    \begin{lstlisting}
CONTEXT Evento :
INV : IdEvento <> "" AND Proprietario <> Null AND Titolo <> ""
    \end{lstlisting}
    In questa classe, è presente il metodo “Crea(NTitolo). Affinchè quest'ultimo possa eseguire, “NTitolo”, ovvero il titolo che si vuole attribuire all'evento che si sta creando, deve essere diverso dalla stringa vuota. Infine, dopo l'esecuzione di questo metodo, l'attributo “Proprietario” deve essere uguale ad UserId, Id dell'utente autenticato che sta creando l'evento, e “Titolo” a “NTitolo”, il titolo scelto per l'evento. \\
    Tali condizioni sono presentati dal seguente codice OCL:
    \begin{lstlisting}
CONTEXT Evento::Crea(NTitolo)
PRE : Ntitolo <> ""
POST : Proprietario = Utente_Autenticato.UserId AND Titolo = NTitolo AND Partecipanti -> exists(u | u.UserId = Utente_Autenticato.UserId )
    \end{lstlisting}
    Infine, in questa classe è presente il metodo “Salva(NTitolo , NDescrizione , NPriorita , NDifficolta , NLuogo)”. Per questo metodo, per eseguire, si deve verificare, come condizione, che il titolo inserito per l'Evento da salvare sia diverso dalla stringa vuota. \\
    Dopo l'esecuzione del metodo, gli attributi dell'oggetto “Evento” saranno uguali ai parametri inseri in tale metodo “Salva”. \\
    Queste condizioni sono rappresentante dal seguente codice OCL:

    \begin{lstlisting}
CONTEXT Evento::Salva(NTitolo, NDescrizione, NPriorita, NDifficolta, NLuogo)
PRE : Ntitolo <> ""
POST : Titolo = NTitolo AND Descrizione = NDescrizione AND Priorita = NPriorita AND Difficolta = NDifficolta AND Luogo = NLuogo 
    \end{lstlisting}




    \elemento[Gestione Chiamate MongoDB]{ocl:GestioneMongoDB}
    \begin{lstlisting}
CONTEXT GestioneChiamateMongoDB :
INV : Link <> "" AND Password <> "" 
    \end{lstlisting}




    \elemento[Tipo Data]{ocl:TipoData}
    \begin{lstlisting}
CONTEXT Tipo_Data:
INV : Ora >= 0 AND Ora <= 23 AND
Minuti >= 0 AND Minuti <= 60 AND
Giorno >= 1 AND Giorno <= 31
Mese >= 1 AND Mese <= 12
    \end{lstlisting}




    \elemento[Tipo Luogo]{ocl:TipoLuogo}
    \begin{lstlisting}
CONTEXT Tipo_Luogo:
INV : Latitudine <> "" AND Longitudine <> "" 
    \end{lstlisting}




    \elemento[Tipo Fuso Orario]{ocl:TipoFusoOrario}
    \begin{lstlisting}
CONTEXT Tipo_Fuso_Orario:
INV : GMToffset >= -12 AND GMToffset <= 12 
    \end{lstlisting}




    \elemento[Tipo Calendario Filtrato]{ocl:TipoCalendarioFiltrato}
    \begin{lstlisting}
CONTEXT Tipo_Calendario_Filtrato
INV: Calendari <> Null
    \end{lstlisting}




    \elemento[Tipo Link Richiesta]{ocl:TipoLinkRichiesta}
    \begin{lstlisting}
CONTEXT Tipo_Link_Richiesta:
INV : (IdCalendario <> "" AND IdEvento = "") OR (IdCalendario = "" AND IdEvento <> "") AND Account <> Null

CONTEXT Tipo_Link_Richiesta::creaRichiesta(IdCalendario, IdEvento, Account)
PRE : (IdCalendario <> "" AND IdEvento = "") OR (IdCalendario = "" AND IdEvento <> "") AND Account <> Null
POST : self.IdCalendario = IdCalendario AND self.IdEvento = IdEvento AND  self.Account = Account  
    \end{lstlisting}




    \elemento[Gestione Luoghi]{ocl:GestioneLuoghi}
    \begin{lstlisting}
Context GestioneLuuoghi::ConvertIndirizzoToCordinate (indirizzo):
PRE : indirizzo <> ""
    \end{lstlisting}




    \elemento[Google Maps API]{ocl:GoogleMapsAPI}
    \begin{lstlisting}
CONTEXT GoogleMapsAPI :
INV : Endpoint <> "" AND ApiToken <> ""
    \end{lstlisting}




    \elemento[OpenStreatMap API]{ocl:OpenStreatMapAPI}
    \begin{lstlisting}
CONTEXT OpenStreetMapAPI :
INV : Endpoint <> ""
    \end{lstlisting}




    \elemento[Impostazioni Ripetizione Base]{ocl:ImpostazioniRipetizioneBase}
    \begin{lstlisting}
CONTEXT ImpostazioniRipetizioneBase:
INV : NumeroRipetizioni >= 1 AND Durata >= 0
    \end{lstlisting}




    \elemento[Giornata]{ocl:Giornata}
    \begin{lstlisting}
CONTEXT Giornata:
INV : GiornoDellaSettimana = "L" OR
GiornoDellaSettimana = "Ma" OR
GiornoDellaSettimana = "Me" OR
GiornoDellaSettimana = "G" OR
GiornoDellaSettimana = "V" OR
GiornoDellaSettimana = "S" OR
GiornoDellaSettimana = "D"
    \end{lstlisting}




    \elemento[Evento Ripetuto]{ocl:EventoRipetuto}
    \begin{lstlisting}
CONTEXT EventoRipetuto:
INV : DurataIntervallo = "Giorno" OR DurataIntervallo = "Settimana" OR DurataIntervallo = "Mese" OR 
DurataIntervallo = "Anno"
    \end{lstlisting}




    \elemento[Evento Singolo]{ocl:EventoSingolo}
    \begin{lstlisting}
CONTEXT EventoSingolo:
INV : Durata >= 0 AND Data <> Null
    \end{lstlisting}




    \elemento[Sistema Di Pagamento]{ocl:SistemaPagamento}
    \begin{lstlisting}
CONTEXT SistemaDiPagamento :
INV : TipoPagamento = "PayPal" OR TipoPagamento = "Stripe"

CONTEXT SistemaDiPagamento::CambiaSistemaDiPagamento(NSistema) :
POST : TipoPagamento = NSistema
    \end{lstlisting}




    \elemento[Stripe API]{ocl:StripeAPI}
    \begin{lstlisting}
CONTEXT StripeAPI :
INV : ProductId <> "" AND EndPoint <> ""

CONTEXT StripeAPI::PagaSubscription() :
POST : UserPaymentToken <> "" AND PaymentId <> ""
    \end{lstlisting}




    \elemento[PayPal API]{ocl:PayPalAPI}
    \begin{lstlisting}
CONTEXT PayPalAPI :
INV : ProductId <> "" AND EndPoint <> ""

CONTEXT PayPalAPI::PagaSubscription() :
POST : PayPalEmail <> "" AND PayPalUserName <> "" AND SubscriptionId <> ""
    \end{lstlisting}




    \elemento[Abbonamento]{ocl:Abbonamento}
    \begin{lstlisting}
CONTEXT Abbonamento::SottoscrizioneAbbonamento() :
PRE Abbonato = false
POST Abbonato = true

CONTEXT Abbonamento::CancellazioneAbbonamento() :
PRE Abbonato = true
POST Abbonato = false
    \end{lstlisting}




    \elemento[GoogleCalendar]{ocl:GoogleCalendar}
    Nella classe “Google Calendar” c'è il metodo “CambiaTipologiaInterazione()”. La sua esecuzione modifica il valore dell'attributo booleano “sincronizzazione” che diventa l'inverso del valore precedente all'esecuzione del metodo.\\
    Tale postcondizione è rappresentata dal codice OCL:
    \begin{lstlisting}
CONTEXT Abbonamento::CambiaTipologiaInterazione() :
POST : sincronizzazione = NOT sincronizzazione@pre 
    \end{lstlisting}




    \elemento[Gestione Import/Export]{ocl:GestioneImportExport}
    \begin{lstlisting}
CONTEXT GestioneImportExport :
INV : Sincronizzazione = false
    \end{lstlisting}




    \elemento[Gestione Sincronizzazione]{ocl:GestioneSincronizzazione}
    \begin{lstlisting}
CONTEXT GestioneSincronizzazione :
INV : Sincronizzazione = true AND authorizationToken <> ""
    \end{lstlisting}




    \elemento[Google Calendar API]{ocl:GoogleCalendarAPI}
    \begin{lstlisting}
CONTEXT GoogleCalendar :
INV : Endpoint <> ""
    \end{lstlisting}




    \elemento[Iubenda]{ocl:Iubenda}
    \begin{lstlisting}
CONTEXT Iubenda :
INV CookieBannerCode <> "" AND PoliticheDiPrivacy <> ""

CONTEXT Iubenda::AccettaCookie(NomeCookie) :
POST : CookieAccettati.size() = CookieAccettati.size()@pre +1 AND CookieAcettati -> exists(c | c.Nome = NomeCookie)

CONTEXT Iubenda::RifiutaCookie(NomeCookie) :
POST : CookieAccettati.size() = CookieAccettati.size()@pre AND NOT (CookieAcettati -> exists(c | c.Nome = NomeCookie))

CONTEXT Iubenda::AccettaTuttiCookies() :
POST : CookieAccettati.size() = ListaCookie.size() AND ListaCookies -> forAll (lc | CookieAccettati -> exists(c | c.Nome = lc.Nome))

CONTEXT Iubenda::RifiutaTuttiCookies() :
POST : CookieAccettati.size() = 0
    \end{lstlisting}




    \elemento[Tipo Cookie]{ocl:TipoCookie}
    \begin{lstlisting}
CONTEXT Tipo_Cookies :
INV : Nome <> "" 

CONTEXT Tipo_Cookie::CreaCookie(Nome, Scadenza, Chiave, Valore):
PRE Iubenda.CookieAccettati -> exists(c | c.nome=Nome)
POST  Homepage.Cookie -> exists(c | c.nome=Nome AND c.Scadenza =  Scadenza AND c.Chiave = Chiave AND c.Valore = Valore) 

CONTEXT Tipo_Cookie::CancellaCookie(Nome)
POST : NOT ( Homepage.Cookie -> exists (c | c.Nome = Nome))
    \end{lstlisting}


\end{listaPersonale}
